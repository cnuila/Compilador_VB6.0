package paquetePrincipal;
import java_cup.runtime.Symbol;
import java.util.ArrayList;

parser code
{:
    public Nodo raiz;    
    public int cont = 0;
    public ArrayList<String> errores = new ArrayList<>();

    public void syntax_error(Symbol s){
        errores.add("Syntax error: " +  s.value + " Linea: " + (s.left + 1) + " Columna: " + (s.right + 1));
    }

    //public void unrecovered_syntax_error
:}

terminal IF, ELSE, END, THEN, ELSEIF, IGUAL, STRUCTURE, LLAMADOSTRUC, saltoLinea, DIM, COMA, AS, BOOLEANTYPE, TRUE, FALSE, INTEGERTYPE, STRINGTYPE, AND, OR, NOT, NEW, MODULE, SUB, PARENTESISL, PARENTESISR, EXIT, FOR, TO, NEXT, WHILE, DO, LOOP, RETURN, CONCATSTRING, FUNCTION, READ, WRITE;
terminal String identificador, STRING, INTEGER, OPADICION, OPMULTI, OPREL;

nonterminal S,STRUCTUREDECLA, ASIGNSTRUC, FORSUB, DOWHILESUB, FORFUNC, DOWHILEFUNC, COUNTER;
nonterminal Nodo MDLINSTRUC, MDLINP, SUBPROCE, FUNC, WRCONSOLE, TIPOIGUAL, OPARIT, CANTVARS, VARS, DECLARACION, T, OPP, OP, CALL, PARAMCALL, VARCALL, VAL, VALASIGN, VALINT, OPASING, ASIGN, ASIGNINT, ASIGNOTRO, PARAMS, VALCOND, CONDICION, CONDICIONP, RETVAL, SIFFUNC, SIFSUB, IFSUB, IFFUNC, SUBINSTRUC, FUNCINSTRUC;
nonterminal String VALWR, UNIRSTRNG, VALUNIRSTR, TIPO, OPCONDICION;

precedence left IGUAL;
precedence left OPREL;
precedence left OPADICION;
precedence left OPMULTI;

start with S;

S      ::= MODULE identificador:id saltoLinea MDLINSTRUC:m END MODULE {:
            System.out.println("Listo Module");
            Nodo node = new Nodo("INICIO",parser.cont);
            parser.cont++;
            node.addHijo(new Nodo("MODULE", parser.cont));
            parser.cont++;
            node.addHijo(new Nodo(id, parser.cont));
            parser.cont++;
            node.addHijo(m);
            parser.raiz = node;            
        :}
            | error identificador saltoLinea MDLINSTRUC END MODULE {: errores.add("Se esparaba un MODULE"); :}
            | MODULE error saltoLinea MDLINSTRUC END MODULE {: errores.add("Se esperaba un identificador para el module"); :}
            | MODULE identificador error MDLINSTRUC END MODULE {: errores.add("Se esperaba un salto de línea en el encabezado del module"); :}
            | MODULE identificador saltoLinea MDLINSTRUC error MODULE {: errores.add("Se esperaba un END"); :}
            | MODULE identificador saltoLinea MDLINSTRUC END error {: errores.add("Se esperaba un MODULE al final del archivo"); :}
; 

//Instrucciones dentro del Module
MDLINSTRUC  ::= DECLARACION:d MDLINSTRUC:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | saltoLinea MDLINSTRUC:md {:
                    RESULT = md;
                :}
                | FUNC:f MDLINSTRUC:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(f);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | SUBPROCE:s MDLINP:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(s);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | STRUCTUREDECLA MDLINSTRUC;

MDLINP      ::= DECLARACION:d MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | saltoLinea MDLINP:m {:
                    if (m != null){
                        RESULT=m;
                    }
                :}
                | SUBPROCE:s MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(s);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | FUNC:f MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(f);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | STRUCTUREDECLA MDLINP 
                | saltoLinea {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

//Intrucciones de una Structure
STRUCTUREDECLA   ::= STRUCTURE identificador saltoLinea DECLARACION END STRUCTURE;

//Instrucciones de un subprocedure
SUBPROCE    ::= SUB identificador:id PARENTESISL PARAMS:p PARENTESISR saltoLinea SUBINSTRUC:s END SUB {:
                        Nodo node = new Nodo("SUB",parser.cont);
                        parser.cont++;
                        node.addHijo(new Nodo(id,parser.cont));
                        parser.cont++;
                        if (p != null){
                            node.addHijo(p);
                        }
                        if (s != null){
                            node.addHijo(s);
                        }                          
                        RESULT=node;
                :}
                | SUB error PARENTESISL PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: errores.add("Se esperaba un identificador para el sub"); :}
                | SUB identificador error PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: errores.add("Se esperaba un parentesis izquierdo en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS error saltoLinea SUBINSTRUC END SUB {: errores.add("Se esperaba un parentesis derecho en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS PARENTESISR error SUBINSTRUC END SUB {: errores.add("Se esperaba un salto de linea en el encabezado del sub"); :}
;

SUBINSTRUC  ::= DECLARACION:d SUBINSTRUC:s {:
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (s != null){
                        node.addHijo(s);   
                    }                    
                    RESULT = node;
                :} 
                | saltoLinea SUBINSTRUC:s {:
                    if (s != null){
                        RESULT = s;   
                    }
                :}
                | EXIT SUB SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("EXIT SUB",parser.cont));
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :} 
                | ASIGN:a SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(a);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | CALL:c SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | WRCONSOLE:w SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(w);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | IFSUB:i SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(i);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | FORSUB SUBINSTRUC| DOWHILESUB SUBINSTRUC
                | error SUBINSTRUC {: errores.add("Error desconocido"); :}
                | error SUB SUBINSTRUC {: errores.add("Se esperaba un EXIT o END"); :}                 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

IFSUB       ::= IF CONDICION:c THEN saltoLinea SUBINSTRUC:s SIFSUB:s2 END IF {:
                    Nodo node = new Nodo("IF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    if (s2 != null){
                        node.addHijo(s2);   
                    } 
                    RESULT = node;
                :}
                | IF error THEN saltoLinea SUBINSTRUC SIFSUB END IF {: errores.add("Error en codición del if"); :}
                | IF CONDICION error saltoLinea SUBINSTRUC SIFSUB END IF {: errores.add("Se esperaba un THEN"); :}
                | IF CONDICION THEN error SUBINSTRUC SIFSUB END IF {: errores.add("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea SUBINSTRUC SIFSUB END error {: errores.add("Se esperaba un IF"); :}
;

SIFSUB      ::= ELSEIF CONDICION:c THEN saltoLinea SUBINSTRUC:s SIFSUB:s2 {:
                    Nodo node = new Nodo("ELSEIF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    if (s2 != null){
                        node.addHijo(s2);   
                    }                   
                    RESULT = node;
                :}
                | ELSE saltoLinea SUBINSTRUC:s {:
                    Nodo node = new Nodo("ELSE",parser.cont);
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :}                
                | ELSEIF error THEN saltoLinea SUBINSTRUC SIFSUB {: errores.add("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea SUBINSTRUC SIFSUB {: errores.add("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error SUBINSTRUC SIFSUB {: errores.add("Se esperaba un salto de línea"); :}
                | ELSE error SUBINSTRUC {: errores.add("Se esperaba un salto de línea"); :}
;

DOWHILESUB  ::= DO WHILE CONDICION saltoLinea SUBINSTRUC LOOP | DO saltoLinea SUBINSTRUC LOOP WHILE CONDICION;
FORSUB      ::= FOR COUNTER TO OPARIT saltoLinea SUBINSTRUC NEXT;

//Instrucciones de una función
FUNC        ::= FUNCTION identificador:id PARENTESISL PARAMS:p PARENTESISR AS TIPO:t saltoLinea FUNCINSTRUC:f END FUNCTION {:
                        Nodo node = new Nodo("FUNCTION",parser.cont);
                        parser.cont++;
                        node.addHijo(new Nodo(id,parser.cont));
                        parser.cont++;
                        if (p != null){
                            node.addHijo(p);
                        }                        
                        node.addHijo(new Nodo(t,parser.cont));
                        parser.cont++;
                        if (f != null){
                            node.addHijo(f);
                        }                        
                        RESULT=node;
                :}
                | FUNCTION error PARENTESISL PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un identificador para la función"); :}
                | FUNCTION identificador error PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un parentesis izquierdo en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS error AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un parentesis derecho en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR error TIPO saltoLinea FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un AS en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS error saltoLinea FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un TIPO en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS TIPO error FUNCINSTRUC END FUNCTION {: errores.add("Se esperaba un salto de línea en el encabezado de la función"); :}
;

FUNCINSTRUC ::= DECLARACION:d FUNCINSTRUC:f {:
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (f != null){
                        node.addHijo(f);
                    }                   
                    RESULT = node;
                :} 
                | saltoLinea FUNCINSTRUC
                | EXIT FUNCTION FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("EXIT FUNCTION",parser.cont));
                    parser.cont++;
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | ASIGN:a FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(a);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | RETVAL:r FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(r);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | CALL:c FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | WRCONSOLE:w FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(w);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | IFFUNC:i FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(i);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | FORFUNC FUNCINSTRUC | DOWHILEFUNC FUNCINSTRUC 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :}
                | error FUNC FUNCINSTRUC {: errores.add("Se esperaba un EXIT o END"); :} 
                | error FUNCINSTRUC {: errores.add("Error desconocido"); :}       
;

IFFUNC      ::= IF CONDICION:c THEN saltoLinea FUNCINSTRUC:f SIFFUNC:s END IF{:
                    Nodo node = new Nodo("IF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }
                    if (s != null){
                        node.addHijo(s);
                    }                    
                    RESULT = node;
                :}
                | IF error THEN saltoLinea FUNCINSTRUC SIFFUNC END IF {: errores.add("Error en codición del if"); :}
                | IF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC END IF {: errores.add("Se esperaba un THEN"); :}
                | IF CONDICION THEN error FUNCINSTRUC SIFFUNC END IF {: errores.add("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea FUNCINSTRUC SIFFUNC END error {: errores.add("Se esperaba un IF"); :} 
;        

SIFFUNC     ::= ELSEIF CONDICION:c THEN saltoLinea FUNCINSTRUC:f SIFFUNC:s {:
                    Nodo node = new Nodo("ELSEIF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }
                    if (s != null){
                        node.addHijo(s);
                    }                    
                    RESULT = node;
                :}
                | ELSE saltoLinea FUNCINSTRUC:f SIFFUNC:s {:
                    Nodo node = new Nodo("ELSE",parser.cont);
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);
                    }
                    if (f != null){
                        node.addHijo(f);
                    }
                    node.addHijo(s);
                    RESULT = node;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                  :}
                | ELSEIF error THEN saltoLinea FUNCINSTRUC SIFFUNC {: errores.add("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC {: errores.add("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error FUNCINSTRUC SIFFUNC {: errores.add("Se esperaba un salto de línea"); :}
                | ELSE error SIFFUNC {: errores.add("Se esperaba un salto de línea"); :}
;

FORFUNC     ::= FOR COUNTER TO OPARIT saltoLinea FUNCINSTRUC NEXT;
DOWHILEFUNC ::= DO WHILE CONDICION saltoLinea FUNCINSTRUC LOOP | DO saltoLinea FUNCINSTRUC LOOP WHILE CONDICION;

RETVAL      ::= RETURN VAL:v {:
                    Nodo node = new Nodo("RETURN",parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :};

VAL         ::= VALASIGN:v {:
                    RESULT=v;
                :} 
                | VALINT:v {:
                    RESULT=v;
                :};

//Instrucciones del for
COUNTER     ::= ASIGNINT | identificador AS INTEGERTYPE IGUAL OPARIT;

//llamado de funcion o sub procedure
CALL        ::= identificador:i PARENTESISL PARAMCALL:p PARENTESISR {:
                    Nodo node = new Nodo("FUNCTION CALL",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(i,parser.cont));
                    parser.cont++;
                    if (p != null){
                        node.addHijo(p);
                    }                    
                    RESULT = node;
                :}
                | error PARENTESISL PARAMCALL PARENTESISR {: errores.add("Se esperaba identificador"); :}
;                

PARAMCALL   ::= VARCALL:v {:
                    RESULT=v;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

VARCALL     ::= VARCALL:v COMA VAL:val {:
                    Nodo node = new Nodo("VARCALL",parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    node.addHijo(val);
                    RESULT = node;
                :}
                | VAL:v {:
                    RESULT = v;
                :}
                | VARCALL error {: errores.add("Error en parametros"); :};

//gramática condiciones
CONDICION   ::= CONDICION:c AND CONDICIONP:c1 {:
                    Nodo node = new Nodo("AND",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(c1);
                    RESULT=node;
                :}
                | CONDICION:c OR CONDICIONP:c1 {:
                    Nodo node = new Nodo("OR",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(c1);
                    RESULT=node;
                :}
                | NOT CONDICIONP:c {:
                    Nodo node = new Nodo("NOT",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    RESULT=node;
                :}
;
CONDICION   ::= CONDICIONP:c {: RESULT = c; :};

CONDICIONP  ::= VALCOND:v OPCONDICION:o VALCOND:v2 {:
                    Nodo node = new Nodo(o,parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    node.addHijo(v2);
                    RESULT = node;
                :};

OPCONDICION ::= OPREL:o {: 
                    RESULT=o;
                :} 
                | IGUAL {: 
                    RESULT="=";
                :}
;              

VALCOND     ::= VALASIGN:v {:
                    RESULT=v;
                :}  
                | VALINT:v {:
                    RESULT=v;
                :} 
;

//gramática parámetros
PARAMS      ::=  VARS:v {: 
                    RESULT = v;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

//gramática asignacion
ASIGN       ::= ASIGNOTRO:a {:
                    RESULT = a;
                :}
                | ASIGNINT:a {:
                    RESULT = a;
                :}
                | ASIGNSTRUC; 

ASIGNOTRO   ::= identificador:id IGUAL VALASIGN:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT=node;
                :};

ASIGNSTRUC  ::= LLAMADOSTRUC IGUAL VALASIGN | LLAMADOSTRUC OPASING VALINT;

VALASIGN    ::= STRING:str {:
                    Nodo node = new Nodo(str.substring(1,str.length()-1),parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | TRUE {:
                    Nodo node = new Nodo("TRUE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | FALSE {:
                    Nodo node = new Nodo("FALSE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | UNIRSTRNG:ustr {:
                    Nodo node = new Nodo(ustr,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | READ {:
                    Nodo node = new Nodo("read console",parser.cont);
                    parser.cont++;
                    RESULT = node;
                :} ;

UNIRSTRNG   ::= VALUNIRSTR:v CONCATSTRING UNIRSTRNG:ustr {:
                    RESULT=v+ustr;
                :} 
                | VALUNIRSTR:v CONCATSTRING VALUNIRSTR:v2 {:
                    RESULT= v+v2;
                :}
;

VALUNIRSTR  ::= STRING:str {: RESULT=str.substring(1,str.length()-1); :} | identificador:id {:RESULT=id;:} | error {: errores.add("Se esperaba un valor String"); :};

ASIGNINT    ::= identificador:id OPASING:o VALINT:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador error VALINT {: errores.add("Error en asignación"); :}
                | error OPASING VALINT {: errores.add("Error en asignación"); :}
;

OPASING     ::= IGUAL {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | OPMULTI:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
                | OPADICION:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
;

VALINT      ::= OPARIT:o {:
                    RESULT = o;
                :};

//gramática operaciones aritméticas
OPARIT      ::= OPARIT:o OPADICION:oPa OP:op {:                     
                    Nodo node = new Nodo(oPa,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                  
                :} 
                | OP:o {:                     
                    RESULT = o;                    
                :} 
;

OP          ::= OP:o OPMULTI:oM OPP:op {: 
                    Nodo node = new Nodo(oM,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                    
                :} 
                | OPP:o {:                     
                    RESULT = o;                    
                :} 
;

OPP         ::= INTEGER:i {: 
                    Nodo node = new Nodo(i,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | identificador:id {: 
                    Nodo node = new Nodo(id,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | CALL:c {: 
                    RESULT = c;                    
                :}  
                | PARENTESISL OPARIT:o PARENTESISR {: 
                    RESULT = o;                    
                :} 
                | error {: errores.add("Error en operación con Integer"); :}
;

//gramática declaración de variables
DECLARACION ::= DIM T:t {:
                    RESULT=t;
                :} 
                | DIM error {: errores.add("Error en declaración"); :}
;

T           ::= identificador:id AS TIPOIGUAL:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(t);
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | identificador AS identificador IGUAL NEW CALL
;

VARS        ::= CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | CANTVARS error {: errores.add("Error en variables"); :}
;

CANTVARS    ::= CANTVARS:c COMA identificador:id {:
                    Nodo node = new Nodo("VARS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | identificador:id {:
                    Nodo node = new Nodo(id,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}
;

TIPOIGUAL   ::= INTEGERTYPE IGUAL OPARIT:o  {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("INTEGER",parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    RESULT=node;                    
                :}
                | STRINGTYPE IGUAL STRING:str {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("STRING",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(str.substring(1,str.length()-1),parser.cont));
                    parser.cont++;
                    RESULT=node; 
                :}
                | BOOLEANTYPE IGUAL TRUE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("TRUE",parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | BOOLEANTYPE IGUAL FALSE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("FALSE",parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | STRINGTYPE IGUAL UNIRSTRNG:ustr {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("STRING",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(ustr,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
;

TIPO        ::= INTEGERTYPE {: RESULT="INTEGER"; :} | STRINGTYPE {: RESULT="STRING"; :} | BOOLEANTYPE {: RESULT="BOOLEAN"; :} ;

//gramática escribir en consola
WRCONSOLE   ::= WRITE PARENTESISL VALWR:v PARENTESISR {:
                    Nodo node = new Nodo("console.write",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(v,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | WRITE error VALWR PARENTESISR {: errores.add("Error en console.write"); :}       
                
;

VALWR       ::= identificador:id {: RESULT=id; :} | STRING:str {: RESULT=str.substring(1,str.length()-1);; :} | UNIRSTRNG:ustr {: RESULT=ustr; :} | error {: errores.add("Se esperaba un String"); :};