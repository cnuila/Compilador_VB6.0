
import java_cup.runtime.Symbol;

parser code
{:
    public Nodo raiz;    
    public int cont = 0;

    public void syntax_error(Symbol s){
        System.out.println("Syntax error: " +  s.value + " Linea: " + (s.left + 1) + " Columna: " + (s.right + 1));
    }

    //public void unrecovered_syntax_error
:}

terminal IF, ELSE, END, THEN, ELSEIF, IGUAL, STRUCTURE, LLAMADOSTRUC, saltoLinea, DIM, COMA, AS, BOOLEANTYPE, TRUE, FALSE, INTEGERTYPE, STRINGTYPE, OPREL, AND, OR, NOT, NEW, MODULE, SUB, PARENTESISL, PARENTESISR, EXIT, FOR, TO, NEXT, WHILE, DO, LOOP, RETURN, CONCATSTRING, FUNCTION, READ, WRITE;
terminal String identificador, STRING, INTEGER, OPADICION, OPMULTI;

nonterminal S, MDLINP, SUBPROCE,STRUCTUREDECLA, ASIGNSTRUC, SUBINSTRUC, SIFSUB, FUNC, FUNCINSTRUC, SIFFUNC, RETVAL, CONDICION, CONDICIONP, OPCONDICION, FORSUB, DOWHILESUB, FORFUNC, DOWHILEFUNC, COUNTER, IFSUB, IFFUNC;
nonterminal Nodo MDLINSTRUC, WRCONSOLE, TIPOIGUAL, OPARIT, CANTVARS, VARS, DECLARACION, T, OPP, OP, CALL, PARAMCALL, VARCALL, VAL, VALASIGN, VALINT, OPASING, ASIGN, ASIGNINT, ASIGNOTRO,PARAMS,VALCOND;
nonterminal String VALWR, UNIRSTRNG, VALUNIRSTR, TIPO;

precedence left IGUAL;
precedence left OPREL;
precedence left OPADICION;
precedence left OPMULTI;

start with S;

S      ::= MODULE identificador:id saltoLinea MDLINSTRUC:m END MODULE {:
            System.out.println("Listo Module");
            Nodo node = new Nodo("INICIO",parser.cont);
            parser.cont++;
            node.addHijo(new Nodo("MODULE", parser.cont));
            parser.cont++;
            node.addHijo(new Nodo(id, parser.cont));
            parser.cont++;
            node.addHijo(m);
            parser.raiz = node;            
        :}
            | error identificador saltoLinea MDLINSTRUC END MODULE {: System.out.println("Se esparaba un MODULE"); :}
            | MODULE error saltoLinea MDLINSTRUC END MODULE {: System.out.println("Se esperaba un identificador para el module"); :}
            | MODULE identificador error MDLINSTRUC END MODULE {: System.out.println("Se esperaba un salto de línea en el encabezado del module"); :}
            | MODULE identificador saltoLinea MDLINSTRUC error MODULE {: System.out.println("Se esperaba un END"); :}
            | MODULE identificador saltoLinea MDLINSTRUC END error {: System.out.println("Se esperaba un MODULE al final del archivo"); :}
; 

//Instrucciones dentro del Module
MDLINSTRUC  ::= DECLARACION:d MDLINSTRUC {:                    
                    RESULT=d;
                :}
                | saltoLinea MDLINSTRUC | FUNC MDLINSTRUC | SUBPROCE MDLINP| STRUCTUREDECLA MDLINSTRUC;
MDLINP      ::= DECLARACION MDLINP | saltoLinea MDLINP | SUBPROCE MDLINP | FUNC MDLINP | STRUCTUREDECLA MDLINP | saltoLinea;

//Intrucciones de una Structure
STRUCTUREDECLA   ::= STRUCTURE identificador saltoLinea DECLARACION END STRUCTURE;

//Instrucciones de un subprocedure
SUBPROCE    ::= SUB identificador PARENTESISL PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB
                | SUB error PARENTESISL PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un identificador para el sub"); :}
                | SUB identificador error PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un parentesis izquierdo en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS error saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un parentesis derecho en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS PARENTESISR error SUBINSTRUC END SUB {: System.out.println("Se esperaba un salto de linea en el encabezado del sub"); :}
;

SUBINSTRUC  ::= DECLARACION SUBINSTRUC | saltoLinea SUBINSTRUC | EXIT SUB SUBINSTRUC | ASIGN SUBINSTRUC | CALL SUBINSTRUC | WRCONSOLE SUBINSTRUC| IFSUB SUBINSTRUC| FORSUB SUBINSTRUC| DOWHILESUB SUBINSTRUC
                | error SUBINSTRUC {: System.out.println("Error desconocido"); :}
                | error SUB SUBINSTRUC {: System.out.println("Se esperaba un EXIT o END"); :}                 
                | ;

IFSUB       ::= IF CONDICION THEN saltoLinea SUBINSTRUC SIFSUB END IF
                | IF error THEN saltoLinea SUBINSTRUC SIFSUB END IF {: System.out.println("Error en codición del if"); :}
                | IF CONDICION error saltoLinea SUBINSTRUC SIFSUB END IF {: System.out.println("Se esperaba un THEN"); :}
                | IF CONDICION THEN error SUBINSTRUC SIFSUB END IF {: System.out.println("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea SUBINSTRUC SIFSUB END error {: System.out.println("Se esperaba un IF"); :}
;

SIFSUB      ::= ELSEIF CONDICION THEN saltoLinea SUBINSTRUC SIFSUB 
                | ELSE saltoLinea SUBINSTRUC 
                |
                | ELSEIF error THEN saltoLinea SUBINSTRUC SIFSUB {: System.out.println("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea SUBINSTRUC SIFSUB {: System.out.println("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error SUBINSTRUC SIFSUB {: System.out.println("Se esperaba un salto de línea"); :}
                | ELSE error SUBINSTRUC {: System.out.println("Se esperaba un salto de línea"); :}
;
DOWHILESUB  ::= DO WHILE CONDICION saltoLinea SUBINSTRUC LOOP | DO saltoLinea SUBINSTRUC LOOP WHILE CONDICION;
FORSUB      ::= FOR COUNTER TO OPARIT saltoLinea SUBINSTRUC NEXT;

//Instrucciones de una función
FUNC        ::= FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION
                | FUNCTION error PARENTESISL PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un identificador para la función"); :}
                | FUNCTION identificador error PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un parentesis izquierdo en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS error AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un parentesis derecho en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR error TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un AS en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS error saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un TIPO en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS TIPO error FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un salto de línea en el encabezado de la función"); :}
;

FUNCINSTRUC ::= DECLARACION FUNCINSTRUC | saltoLinea FUNCINSTRUC | EXIT FUNCTION FUNCINSTRUC | ASIGN FUNCINSTRUC | RETVAL FUNCINSTRUC | CALL FUNCINSTRUC | WRCONSOLE FUNCINSTRUC | IFFUNC FUNCINSTRUC| FORFUNC FUNCINSTRUC | DOWHILEFUNC FUNCINSTRUC 
                | 
                | error FUNC FUNCINSTRUC {: System.out.println("Se esperaba un EXIT o END"); :} 
                | error FUNCINSTRUC {: System.out.println("Error desconocido"); :}       
;

IFFUNC      ::= IF CONDICION THEN saltoLinea FUNCINSTRUC SIFFUNC END IF
                | IF error THEN saltoLinea FUNCINSTRUC SIFFUNC END IF {: System.out.println("Error en codición del if"); :}
                | IF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC END IF {: System.out.println("Se esperaba un THEN"); :}
                | IF CONDICION THEN error FUNCINSTRUC SIFFUNC END IF {: System.out.println("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea FUNCINSTRUC SIFFUNC END error {: System.out.println("Se esperaba un IF"); :} 
;        

SIFFUNC     ::= ELSEIF CONDICION THEN saltoLinea FUNCINSTRUC SIFFUNC 
                | ELSE saltoLinea SIFFUNC 
                |
                | ELSEIF error THEN saltoLinea FUNCINSTRUC SIFFUNC {: System.out.println("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC {: System.out.println("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error FUNCINSTRUC SIFFUNC {: System.out.println("Se esperaba un salto de línea"); :}
                | ELSE error SIFFUNC {: System.out.println("Se esperaba un salto de línea"); :}
;

FORFUNC     ::= FOR COUNTER TO OPARIT saltoLinea FUNCINSTRUC NEXT;
DOWHILEFUNC ::= DO WHILE CONDICION saltoLinea FUNCINSTRUC LOOP | DO saltoLinea FUNCINSTRUC LOOP WHILE CONDICION;

RETVAL      ::= RETURN VAL;

VAL         ::= VALASIGN:v {:
                    RESULT=v;
                :} 
                | VALINT:v {:
                    RESULT=v;
                :} ;

//Instrucciones del for
COUNTER     ::= ASIGNINT | identificador AS INTEGERTYPE IGUAL OPARIT;

//llamado de funcion o sub procedure
CALL        ::= identificador:i PARENTESISL PARAMCALL:p PARENTESISR {:
                    Nodo node = new Nodo("FUNCTION CALL",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(i,parser.cont));
                    parser.cont++;
                    node.addHijo(p);
                    RESULT = node;
                :}
                | error PARENTESISL PARAMCALL PARENTESISR {: System.out.println("Se esperaba identificador"); :}
;                

PARAMCALL   ::= VARCALL:v {:
                    RESULT=v;
                :} 
                | ;

VARCALL     ::= VARCALL:v COMA VAL:val {:
                    Nodo node = new Nodo("VARCALL",parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    node.addHijo(val);
                    RESULT = node;
                :}
                | VAL:v {:
                    RESULT = v;
                :}
                | VARCALL error {: System.out.println("Error en parametros"); :};

//gramática condiciones
CONDICION   ::= CONDICION AND CONDICIONP 
                | CONDICION OR CONDICIONP 
                | NOT CONDICIONP
;
CONDICION   ::= CONDICIONP;
CONDICIONP  ::= VALCOND OPCONDICION VALCOND;
OPCONDICION ::= OPREL | IGUAL;              

VALCOND     ::= VALASIGN:v {:
                    RESULT=v;
                :}  
                | VALINT:v {:
                    RESULT=v;
                :} 
;

//gramática parámetros
PARAMS      ::=  VARS:v {: 
                    RESULT = v;
                :} | ;

//gramática asignacion
ASIGN       ::= ASIGNOTRO:a {:
                    RESULT = a;
                :}
                | ASIGNINT:a {:
                    RESULT = a;
                :}
                | ASIGNSTRUC; 

ASIGNOTRO   ::= identificador:id IGUAL VALASIGN:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT=node;
                :};

ASIGNSTRUC  ::= LLAMADOSTRUC IGUAL VALASIGN | LLAMADOSTRUC OPASING VALINT;

VALASIGN    ::= STRING:str {:
                    Nodo node = new Nodo(str,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | TRUE {:
                    Nodo node = new Nodo("TRUE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | FALSE {:
                    Nodo node = new Nodo("FALSE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | UNIRSTRNG:ustr {:
                    Nodo node = new Nodo(ustr,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | READ {:
                    Nodo node = new Nodo("read console",parser.cont);
                    parser.cont++;
                    RESULT = node;
                :} ;

UNIRSTRNG   ::= VALUNIRSTR:v CONCATSTRING UNIRSTRNG:ustr {:
                    RESULT=v+ustr;
                :} 
                | VALUNIRSTR:v CONCATSTRING VALUNIRSTR:v2 {:
                    RESULT= v+v2;
                :}
;

VALUNIRSTR  ::= STRING:str {: RESULT=str; :} | identificador:id {:RESULT=id;:} | error {: System.out.println("Se esperaba un valor String"); :};

ASIGNINT    ::= identificador:id OPASING:o VALINT:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador error VALINT {: System.out.println("Error en asignación"); :}
                | error OPASING VALINT {: System.out.println("Error en asignación"); :}
;

OPASING     ::= IGUAL {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | OPMULTI:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
                | OPADICION:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
;

VALINT      ::= OPARIT:o {:
                    RESULT = o;
                :};

//gramática operaciones aritméticas
OPARIT      ::= OPARIT:o OPADICION:oPa OP:op {:                     
                    Nodo node = new Nodo(oPa,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                  
                :} 
                | OP:o {:                     
                    RESULT = o;                    
                :} 
;

OP          ::= OP:o OPMULTI:oM OPP:op {: 
                    Nodo node = new Nodo(oM,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                    
                :} 
                | OPP:o {:                     
                    RESULT = o;                    
                :} 
;

OPP         ::= INTEGER:i {: 
                    Nodo node = new Nodo(i,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | identificador:id {: 
                    Nodo node = new Nodo(id,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | CALL:c {: 
                    RESULT = c;                    
                :}  
                | PARENTESISL OPARIT:o PARENTESISR {: 
                    RESULT = o;                    
                :} 
                | error {: System.out.println("Error en operación con Integer"); :}
;

//gramática declaración de variables
DECLARACION ::= DIM T:t {:
                    RESULT=t;
                :} 
                | DIM error {: System.out.println("Error en declaración"); :}
;

T           ::= identificador:id AS TIPOIGUAL:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(t);
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | identificador AS identificador IGUAL NEW CALL
;

VARS        ::= CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | CANTVARS error {: System.out.println("Error en variables"); :}
;

CANTVARS    ::= CANTVARS:c COMA identificador:id {:
                    Nodo node = new Nodo("VARS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | identificador:id {:
                    Nodo node = new Nodo(id,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}
;

TIPOIGUAL   ::= INTEGERTYPE IGUAL OPARIT:o  {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("INTEGER",parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    RESULT=node;                    
                :}
                | STRINGTYPE IGUAL STRING:str {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("STRING",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(str,parser.cont));
                    parser.cont++;
                    RESULT=node; 
                :}
                | BOOLEANTYPE IGUAL TRUE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("TRUE",parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | BOOLEANTYPE IGUAL FALSE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("FALSE",parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | STRINGTYPE IGUAL UNIRSTRNG:ustr {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(ustr,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
;

TIPO        ::= INTEGERTYPE {: RESULT="INTEGER"; :} | STRINGTYPE {: RESULT="STRING"; :} | BOOLEANTYPE {: RESULT="BOOLEAN"; :} ;

//gramática escribir en consola
WRCONSOLE   ::= WRITE PARENTESISL VALWR:v PARENTESISR {:
                    Nodo node = new Nodo("console.write",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(v,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | WRITE error VALWR PARENTESISR {: System.out.println("Error en console.write"); :}       
                
;

VALWR       ::= identificador:id {: RESULT=id; :} | STRING:str {: RESULT=str; :} | UNIRSTRNG:ustr {: RESULT=ustr; :} | error {: System.out.println("Se esperaba un String"); :};