package paquetePrincipal;
import java_cup.runtime.Symbol;

parser code
{:
    public Nodo raiz;    
    public int cont = 0;

    public void syntax_error(Symbol s){
        System.out.println("Syntax error: " +  s.value + " Linea: " + (s.left + 1) + " Columna: " + (s.right + 1));
    }

    //public void unrecovered_syntax_error
:}

terminal IF, ELSE, END, THEN, ELSEIF, IGUAL, STRUCTURE, LLAMADOSTRUC, saltoLinea, DIM, COMA, AS, BOOLEANTYPE, TRUE, FALSE, INTEGERTYPE, STRINGTYPE, AND, OR, NOT, NEW, MODULE, SUB, PARENTESISL, PARENTESISR, EXIT, FOR, TO, NEXT, WHILE, DO, LOOP, RETURN, CONCATSTRING, FUNCTION, READ, WRITE;
terminal String identificador, STRING, INTEGER, OPADICION, OPMULTI, OPREL;

nonterminal S,STRUCTUREDECLA, ASIGNSTRUC, FORSUB, DOWHILESUB, FORFUNC, DOWHILEFUNC, COUNTER;
nonterminal Nodo MDLINSTRUC, MDLINP, SUBPROCE, FUNC, WRCONSOLE, TIPOIGUAL, OPARIT, CANTVARS, VARS, DECLARACION, T, OPP, OP, CALL, PARAMCALL, VARCALL, VAL, VALASIGN, VALINT, OPASING, ASIGN, ASIGNINT, ASIGNOTRO, PARAMS, VALCOND, CONDICION, CONDICIONP, RETVAL, SIFFUNC, SIFSUB, IFSUB, IFFUNC, SUBINSTRUC, FUNCINSTRUC;
nonterminal String VALWR, UNIRSTRNG, VALUNIRSTR, TIPO, OPCONDICION;

precedence left IGUAL;
precedence left OPREL;
precedence left OPADICION;
precedence left OPMULTI;

start with S;

S      ::= MODULE identificador:id saltoLinea MDLINSTRUC:m END MODULE {:
            System.out.println("Listo Module");
            Nodo node = new Nodo("INICIO",parser.cont);
            parser.cont++;
            node.addHijo(new Nodo("MODULE", parser.cont));
            parser.cont++;
            node.addHijo(new Nodo(id, parser.cont));
            parser.cont++;
            node.addHijo(m);
            parser.raiz = node;            
        :}
            | error identificador saltoLinea MDLINSTRUC END MODULE {: System.out.println("Se esparaba un MODULE"); :}
            | MODULE error saltoLinea MDLINSTRUC END MODULE {: System.out.println("Se esperaba un identificador para el module"); :}
            | MODULE identificador error MDLINSTRUC END MODULE {: System.out.println("Se esperaba un salto de línea en el encabezado del module"); :}
            | MODULE identificador saltoLinea MDLINSTRUC error MODULE {: System.out.println("Se esperaba un END"); :}
            | MODULE identificador saltoLinea MDLINSTRUC END error {: System.out.println("Se esperaba un MODULE al final del archivo"); :}
; 

//Instrucciones dentro del Module
MDLINSTRUC  ::= DECLARACION:d MDLINSTRUC:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | saltoLinea MDLINSTRUC:md {:
                    RESULT = md;
                :}
                | FUNC:f MDLINSTRUC:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(f);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | SUBPROCE:s MDLINP:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(s);
                    node.addHijo(md);
                    RESULT=node;
                :}
                | STRUCTUREDECLA:sd MDLINSTRUC:md {:                    
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(sd);
                    node.addHijo(md);
                    RESULT=node;
                :}
;

MDLINP      ::= DECLARACION:d MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | saltoLinea MDLINP:m {:
                    if (m != null){
                        RESULT=m;
                    }
                :}
                | SUBPROCE:s MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(s);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | FUNC:f MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(f);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | STRUCTUREDECLA:sd MDLINP:m {:
                    Nodo node = new Nodo("MODULE INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(sd);
                    if (m != null){
                        node.addHijo(m);
                    }                    
                    RESULT=node;
                :}
                | saltoLinea {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

//Intrucciones de una Structure
STRUCTUREDECLA   ::= STRUCTURE identificador:id saltoLinea DECLARACIONESSTRUCT:d END STRUCTURE{:
                            Nodo node = new Nodo("STRUCTURE",parser.cont);
                            parser.cont++;
                            node.addHijo(new Nodo(id,parser.cont));
                            parser.cont++;
                            if (d != null){
                                node.addHijo(d);
                            }
                            RESULT = node;
                :}
                     | STRUCTURE error saltoLinea DECLARACION END STRUCTURE {: System.out.println("Se esperaba un identificador para la structure"); :}
                     | STRUCTURE identificador error DECLARACION END STRUCTURE {: System.out.println("Se esperaba un salto de linea"); :}
                     | STRUCTURE identificador saltoLinea error END STRUCTURE {: System.out.println("error en la declaracion del structure"); :}
                     | STRUCTURE identificador saltoLinea DECLARACION END error {: System.out.println("Se esperaba un identificador para la structure"); :}
;
DECLARACIONESSTRUCT ::= DECLARACION:d DECLARACIONESSTRUCT:ds {:
                            Nodo node = new Nodo("DECLARACION",parser.cont);
                            node.addHijo(d);
                            parser.cont++;
                            if (ds != null){
                                node.addHijo(ds);
                            }
                            RESULT = node;
                :}
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :}
;
//Instrucciones de un subprocedure
SUBPROCE    ::= SUB identificador:id PARENTESISL PARAMS:p PARENTESISR saltoLinea SUBINSTRUC:s END SUB {:
                        Nodo node = new Nodo("SUB",parser.cont);
                        parser.cont++;
                        node.addHijo(new Nodo(id,parser.cont));
                        parser.cont++;
                        if (p != null){
                            node.addHijo(p);
                        }
                        if (s != null){
                            node.addHijo(s);
                        }                          
                        RESULT=node;
                :}
                | SUB error PARENTESISL PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un identificador para el sub"); :}
                | SUB identificador error PARAMS PARENTESISR saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un parentesis izquierdo en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS error saltoLinea SUBINSTRUC END SUB {: System.out.println("Se esperaba un parentesis derecho en el encabezado del sub"); :}
                | SUB identificador PARENTESISL PARAMS PARENTESISR error SUBINSTRUC END SUB {: System.out.println("Se esperaba un salto de linea en el encabezado del sub"); :}
;

SUBINSTRUC  ::= DECLARACION:d SUBINSTRUC:s {:
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (s != null){
                        node.addHijo(s);   
                    }                    
                    RESULT = node;
                :} 
                | saltoLinea SUBINSTRUC:s {:
                    if (s != null){
                        RESULT = s;   
                    }
                :}
                | EXIT SUB SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("EXIT SUB",parser.cont));
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :} 
                | ASIGN:a SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(a);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | CALL:c SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | WRCONSOLE:w SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(w);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | IFSUB:i SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(i);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | FORSUB:f SUBINSTRUC:s {: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(f);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | DOWHILESUB:d SUBINSTRUC:s{: 
                    Nodo node = new Nodo("SUB INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :}
                | error SUBINSTRUC {: System.out.println("Error desconocido"); :}
                | error SUB SUBINSTRUC {: System.out.println("Se esperaba un EXIT o END"); :}                 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

IFSUB       ::= IF CONDICION:c THEN saltoLinea SUBINSTRUC:s SIFSUB:s2 END IF {:
                    Nodo node = new Nodo("IF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    if (s2 != null){
                        node.addHijo(s2);   
                    } 
                    RESULT = node;
                :}
                | IF error THEN saltoLinea SUBINSTRUC SIFSUB END IF {: System.out.println("Error en codición del if"); :}
                | IF CONDICION error saltoLinea SUBINSTRUC SIFSUB END IF {: System.out.println("Se esperaba un THEN"); :}
                | IF CONDICION THEN error SUBINSTRUC SIFSUB END IF {: System.out.println("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea SUBINSTRUC SIFSUB END error {: System.out.println("Se esperaba un IF"); :}
;

SIFSUB      ::= ELSEIF CONDICION:c THEN saltoLinea SUBINSTRUC:s SIFSUB:s2 {:
                    Nodo node = new Nodo("ELSEIF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    if (s2 != null){
                        node.addHijo(s2);   
                    }                   
                    RESULT = node;
                :}
                | ELSE saltoLinea SUBINSTRUC:s {:
                    Nodo node = new Nodo("ELSE",parser.cont);
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);   
                    }                   
                    RESULT = node;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :}                
                | ELSEIF error THEN saltoLinea SUBINSTRUC SIFSUB {: System.out.println("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea SUBINSTRUC SIFSUB {: System.out.println("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error SUBINSTRUC SIFSUB {: System.out.println("Se esperaba un salto de línea"); :}
                | ELSE error SUBINSTRUC {: System.out.println("Se esperaba un salto de línea"); :}
;

DOWHILESUB  ::= DO WHILE CONDICION:c saltoLinea SUBINSTRUC:s LOOP{:
                            Nodo node = new Nodo("DO WHILE",parser.cont);
                            parser.cont++;
                            node.addHijo(c);
                            if (s != null){
                                node.addHijo(s);
                            }
                            RESULT = node;
                :}
                | error WHILE CONDICION saltoLinea SUBINSTRUC LOOP {: System.out.println("Se esperaba un DO"); :}
                | DO error CONDICION saltoLinea SUBINSTRUC LOOP {: System.out.println("Se esperaba un WHILE"); :}
                | DO WHILE error saltoLinea SUBINSTRUC LOOP {: System.out.println("Error en la condicion"); :}
                | DO WHILE CONDICION error SUBINSTRUC LOOP {: System.out.println("Se esperaba un salto de linea"); :}
                | DO WHILE CONDICION saltoLinea SUBINSTRUC error {: System.out.println("Se esperaba un LOOP"); :}
;

FORSUB      ::= FOR COUNTER:c TO OPARIT:o saltoLinea SUBINSTRUC:s NEXT{:
                            Nodo node = new Nodo("FOR",parser.cont);
                            parser.cont++;
                            node.addHijo(c);
                            node.addHijo(o);
                            if (s != null){
                                node.addHijo(s);
                            }
                            RESULT = node;
                :}
                | error COUNTER TO OPARIT saltoLinea SUBINSTRUC NEXT {: System.out.println("Se esperaba un FOR"); :}
                | FOR error TO OPARIT saltoLinea SUBINSTRUC NEXT {: System.out.println("Error en la asignacion del contador del for"); :}
                | FOR COUNTER error OPARIT saltoLinea SUBINSTRUC NEXT {: System.out.println("Se esperaba un TO"); :}
                | FOR COUNTER TO OPARIT error SUBINSTRUC NEXT {: System.out.println("Se esperaba un salto de linea"); :}
                | FOR COUNTER TO OPARIT saltoLinea SUBINSTRUC error {: System.out.println("Se esperaba un NEXT"); :}
;

//Instrucciones de una función
FUNC        ::= FUNCTION identificador:id PARENTESISL PARAMS:p PARENTESISR AS TIPO:t saltoLinea FUNCINSTRUC:f END FUNCTION {:
                        Nodo node = new Nodo("FUNCTION",parser.cont);
                        parser.cont++;
                        node.addHijo(new Nodo(id,parser.cont));
                        parser.cont++;
                        if (p != null){
                            node.addHijo(p);
                        }                        
                        node.addHijo(new Nodo(t,parser.cont));
                        parser.cont++;
                        if (f != null){
                            node.addHijo(f);
                        }                        
                        RESULT=node;
                :}
                | FUNCTION error PARENTESISL PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un identificador para la función"); :}
                | FUNCTION identificador error PARAMS PARENTESISR AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un parentesis izquierdo en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS error AS TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un parentesis derecho en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR error TIPO saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un AS en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS error saltoLinea FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un TIPO en el encabezado de la función"); :}
                | FUNCTION identificador PARENTESISL PARAMS PARENTESISR AS TIPO error FUNCINSTRUC END FUNCTION {: System.out.println("Se esperaba un salto de línea en el encabezado de la función"); :}
;

FUNCINSTRUC ::= DECLARACION:d FUNCINSTRUC:f {:
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (f != null){
                        node.addHijo(f);
                    }                   
                    RESULT = node;
                :} 
                | saltoLinea FUNCINSTRUC
                | EXIT FUNCTION FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("EXIT FUNCTION",parser.cont));
                    parser.cont++;
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | ASIGN:a FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(a);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | RETVAL:r FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(r);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | CALL:c FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | WRCONSOLE:w FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(w);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | IFFUNC:i FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(i);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | FORFUNC:ff FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(ff);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | DOWHILEFUNC:d FUNCINSTRUC:f {: 
                    Nodo node = new Nodo("FUN INSTRUCTIONS",parser.cont);
                    parser.cont++;
                    node.addHijo(d);
                    if (f != null){
                        node.addHijo(f);
                    }                    
                    RESULT = node;
                :}
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :}
                | error FUNC FUNCINSTRUC {: System.out.println("Se esperaba un EXIT o END"); :} 
                | error FUNCINSTRUC {: System.out.println("Error desconocido"); :}       
;

IFFUNC      ::= IF CONDICION:c THEN saltoLinea FUNCINSTRUC:f SIFFUNC:s END IF{:
                    Nodo node = new Nodo("IF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }
                    if (s != null){
                        node.addHijo(s);
                    }                    
                    RESULT = node;
                :}
                | IF error THEN saltoLinea FUNCINSTRUC SIFFUNC END IF {: System.out.println("Error en codición del if"); :}
                | IF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC END IF {: System.out.println("Se esperaba un THEN"); :}
                | IF CONDICION THEN error FUNCINSTRUC SIFFUNC END IF {: System.out.println("Se esperaba un salto de linea"); :}
                | IF CONDICION THEN saltoLinea FUNCINSTRUC SIFFUNC END error {: System.out.println("Se esperaba un IF"); :} 
;        

SIFFUNC     ::= ELSEIF CONDICION:c THEN saltoLinea FUNCINSTRUC:f SIFFUNC:s {:
                    Nodo node = new Nodo("ELSEIF",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    if (f != null){
                        node.addHijo(f);
                    }
                    if (s != null){
                        node.addHijo(s);
                    }                    
                    RESULT = node;
                :}
                | ELSE saltoLinea SIFFUNC:s {:
                    Nodo node = new Nodo("ELSE",parser.cont);
                    parser.cont++;
                    if (s != null){
                        node.addHijo(s);
                    }
                    node.addHijo(s);
                    RESULT = node;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                  :}
                | ELSEIF error THEN saltoLinea FUNCINSTRUC SIFFUNC {: System.out.println("Error en la condición"); :}
                | ELSEIF CONDICION error saltoLinea FUNCINSTRUC SIFFUNC {: System.out.println("Se esperaba un THEN"); :}
                | ELSEIF CONDICION THEN error FUNCINSTRUC SIFFUNC {: System.out.println("Se esperaba un salto de línea"); :}
                | ELSE error SIFFUNC {: System.out.println("Se esperaba un salto de línea"); :}
;

FORFUNC     ::= FOR COUNTER:c TO OPARIT:o saltoLinea FUNCINSTRUC:f NEXT{:
                            Nodo node = new Nodo("FOR",parser.cont);
                            parser.cont++;
                            node.addHijo(c);
                            node.addHijo(o);
                            if (f != null){
                                node.addHijo(f);
                            }
                            RESULT = node;
                :}
                | error COUNTER TO OPARIT saltoLinea FUNINSTRUC NEXT {: System.out.println("Se esperaba un FOR"); :}
                | FOR error TO OPARIT saltoLinea FUNCINSTRUC NEXT {: System.out.println("Error en la asignacion del contador del for"); :}
                | FOR COUNTER error OPARIT saltoLinea FUNCINSTRUC NEXT {: System.out.println("Se esperaba un TO"); :}
                | FOR COUNTER TO OPARIT error FUNCINSTRUC NEXT {: System.out.println("Se esperaba un salto de linea"); :}
                | FOR COUNTER TO OPARIT saltoLinea FUNCINSTRUC error {: System.out.println("Se esperaba un NEXT"); :}
;

DOWHILEFUNC ::= DO WHILE CONDICION:c saltoLinea FUNCINSTRUC:f LOOP{:
                            Nodo node = new Nodo("DO WHILE",parser.cont);
                            parser.cont++;
                            node.addHijo(c);
                            if (f != null){
                                node.addHijo(f);
                            }
                            RESULT = node;
                :}
                | error WHILE CONDICION saltoLinea FUNCINSTRUC LOOP {: System.out.println("Se esperaba un DO"); :}
                | DO error CONDICION saltoLinea FUNCINSTRUC LOOP {: System.out.println("Se esperaba un WHILE"); :}
                | DO WHILE error saltoLinea FUNCINSTRUC LOOP {: System.out.println("Error en la condicion"); :}
                | DO WHILE CONDICION error FUNCINSTRUC LOOP {: System.out.println("Se esperaba un salto de linea"); :}
                | DO WHILE CONDICION saltoLinea FUNCINSTRUC error {: System.out.println("Se esperaba un LOOP"); :}
;

RETVAL      ::= RETURN VAL:v {:
                    Nodo node = new Nodo("RETURN",parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :};

VAL         ::= VALASIGN:v {:
                    RESULT=v;
                :} 
                | VALINT:v {:
                    RESULT=v;
                :} ;

//Instrucciones del for
COUNTER     ::= ASIGNINT:ai {:
                    RESULT=ai;
                :} 
                | identificador:id AS INTEGERTYPE IGUAL OPARIT:op{:
                            Nodo node = new Nodo("=",parser.cont);
                            parser.cont++;
                            node.addHijo(new Nodo(id,parser.cont));
                            parser.cont++;
                            node.addHijo(new Nodo("INTEGER",parser.cont));
                            parser.cont++;
                            node.addHijo(op);
                            RESULT = node;
                :}
                         | error AS INTEGERTYPE IGUAL OPARIT {: System.out.println("Se esperaba un identificador"); :}
                         | identificador error OPARIT {: System.out.println("Error en asignar el tipo"); :}
;

//llamado de funcion o sub procedure
CALL        ::= identificador:i PARENTESISL PARAMCALL:p PARENTESISR {:
                    Nodo node = new Nodo("FUNCTION CALL",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(i,parser.cont));
                    parser.cont++;
                    if (p != null){
                        node.addHijo(p);
                    }                    
                    RESULT = node;
                :}
                | error PARENTESISL PARAMCALL PARENTESISR {: System.out.println("Se esperaba identificador"); :}
;                

PARAMCALL   ::= VARCALL:v {:
                    RESULT=v;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

VARCALL     ::= VARCALL:v COMA VAL:val {:
                    Nodo node = new Nodo("VARCALL",parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    node.addHijo(val);
                    RESULT = node;
                :}
                | VAL:v {:
                    RESULT = v;
                :}
                | VARCALL error {: System.out.println("Error en parametros"); :};

//gramática condiciones
CONDICION   ::= CONDICION:c AND CONDICIONP:c1 {:
                    Nodo node = new Nodo("AND",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(c1);
                    RESULT=node;
                :}
                | CONDICION:c OR CONDICIONP:c1 {:
                    Nodo node = new Nodo("OR",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(c1);
                    RESULT=node;
                :}
                | NOT CONDICIONP:c {:
                    Nodo node = new Nodo("NOT",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    RESULT=node;
                :}
;
CONDICION   ::= CONDICIONP:c {: RESULT = c; :};

CONDICIONP  ::= VALCOND:v OPCONDICION:o VALCOND:v2 {:
                    Nodo node = new Nodo(o,parser.cont);
                    parser.cont++;
                    node.addHijo(v);
                    node.addHijo(v2);
                    RESULT = node;
                :};

OPCONDICION ::= OPREL:o {: 
                    RESULT=o;
                :} 
                | IGUAL {: 
                    RESULT="=";
                :}
;              

VALCOND     ::= VALASIGN:v {:
                    RESULT=v;
                :}  
                | VALINT:v {:
                    RESULT=v;
                :} 
;

//gramática parámetros
PARAMS      ::=  VARS:v {: 
                    RESULT = v;
                :} 
                | {:
                    Nodo node = new Nodo("VACIO",parser.cont);
                    parser.cont++;                                   
                    RESULT = node;
                :};

//gramática asignacion
ASIGN       ::= ASIGNOTRO:a {:
                    RESULT = a;
                :}
                | ASIGNINT:a {:
                    RESULT = a;
                :}
                | ASIGNSTRUC; 

ASIGNOTRO   ::= identificador:id IGUAL VALASIGN:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT=node;
                :};

ASIGNSTRUC  ::= LLAMADOSTRUC IGUAL VALASIGN | LLAMADOSTRUC OPASING VALINT;

VALASIGN    ::= STRING:str {:
                    Nodo node = new Nodo(str.substring(1,str.length()-1),parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | TRUE {:
                    Nodo node = new Nodo("TRUE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | FALSE {:
                    Nodo node = new Nodo("FALSE",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | UNIRSTRNG:ustr {:
                    Nodo node = new Nodo(ustr,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | READ {:
                    Nodo node = new Nodo("read console",parser.cont);
                    parser.cont++;
                    RESULT = node;
                :} ;

UNIRSTRNG   ::= VALUNIRSTR:v CONCATSTRING UNIRSTRNG:ustr {:
                    RESULT=v+ustr;
                :} 
                | VALUNIRSTR:v CONCATSTRING VALUNIRSTR:v2 {:
                    RESULT= v+v2;
                :}
;

VALUNIRSTR  ::= STRING:str {: RESULT=str.substring(1,str.length()-1); :} | identificador:id {:RESULT=id;:} | error {: System.out.println("Se esperaba un valor String"); :};

ASIGNINT    ::= identificador:id OPASING:o VALINT:v {:
                    Nodo node = new Nodo("ASIGNACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador error VALINT {: System.out.println("Error en asignación"); :}
                | error OPASING VALINT {: System.out.println("Error en asignación"); :}
;

OPASING     ::= IGUAL {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :} 
                | OPMULTI:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
                | OPADICION:op IGUAL {:
                    Nodo node = new Nodo(op+"=",parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}  
;

VALINT      ::= OPARIT:o {:
                    RESULT = o;
                :};

//gramática operaciones aritméticas
OPARIT      ::= OPARIT:o OPADICION:oPa OP:op {:                     
                    Nodo node = new Nodo(oPa,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                  
                :} 
                | OP:o {:                     
                    RESULT = o;                    
                :} 
;

OP          ::= OP:o OPMULTI:oM OPP:op {: 
                    Nodo node = new Nodo(oM,parser.cont); 
                    parser.cont++;
                    node.addHijo(o);
                    node.addHijo(op);
                    RESULT = node;                    
                :} 
                | OPP:o {:                     
                    RESULT = o;                    
                :} 
;

OPP         ::= INTEGER:i {: 
                    Nodo node = new Nodo(i,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | identificador:id {: 
                    Nodo node = new Nodo(id,parser.cont); 
                    parser.cont++;
                    RESULT = node;                    
                :} 
                | CALL:c {: 
                    RESULT = c;                    
                :}  
                | PARENTESISL OPARIT:o PARENTESISR {: 
                    RESULT = o;                    
                :} 
                | error {: System.out.println("Error en operación con Integer"); :}
;

//gramática declaración de variables
DECLARACION ::= DIM T:t {:
                    RESULT=t;
                :} 
                | DIM error {: System.out.println("Error en declaración"); :}
;

T           ::= identificador:id AS TIPOIGUAL:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(t);
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | identificador:id COMA CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | identificador:id AS TIPO:t {:
                    Nodo node = new Nodo("DECLARACION",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
;

VARS        ::= CANTVARS:c AS TIPO:t COMA VARS:v {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    node.addHijo(v);
                    RESULT = node;
                :}
                | CANTVARS:c AS TIPO:t {:
                    Nodo node = new Nodo("VARS", parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(t,parser.cont));
                    parser.cont++;
                    RESULT = node;
                :}
                | CANTVARS error {: System.out.println("Error en variables"); :}
;

CANTVARS    ::= CANTVARS:c COMA identificador:id {:
                    Nodo node = new Nodo("VARS",parser.cont);
                    parser.cont++;
                    node.addHijo(c);
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | identificador:id {:
                    Nodo node = new Nodo(id,parser.cont);
                    parser.cont++;
                    RESULT=node;
                :}
;

TIPOIGUAL   ::= INTEGERTYPE IGUAL OPARIT:o  {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("INTEGER",parser.cont));
                    parser.cont++;
                    node.addHijo(o);
                    RESULT=node;                    
                :}
                | STRINGTYPE IGUAL STRING:str {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("STRING",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(str.substring(1,str.length()-1),parser.cont));
                    parser.cont++;
                    RESULT=node; 
                :}
                | BOOLEANTYPE IGUAL TRUE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("TRUE",parser.cont));
                    parser.cont++;
                    RESULT=node;  
                :}
                | BOOLEANTYPE IGUAL FALSE {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("BOOLEAN",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo("FALSE",parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | STRINGTYPE IGUAL UNIRSTRNG:ustr {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo("STRING",parser.cont));
                    parser.cont++;
                    node.addHijo(new Nodo(ustr,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                |identificador:id IGUAL NEW CALL:c {:
                    Nodo node = new Nodo("=",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(id,parser.cont));
                    parser.cont++;
                    node.addHijo(c);
                    RESULT=node;
                :}
;

TIPO        ::= INTEGERTYPE {: RESULT="INTEGER"; :} | STRINGTYPE {: RESULT="STRING"; :} | BOOLEANTYPE {: RESULT="BOOLEAN"; :} | identificador:id {: RESULT=id :} ;

//gramática escribir en consola
WRCONSOLE   ::= WRITE PARENTESISL VALWR:v PARENTESISR {:
                    Nodo node = new Nodo("console.write",parser.cont);
                    parser.cont++;
                    node.addHijo(new Nodo(v,parser.cont));
                    parser.cont++;
                    RESULT=node;
                :}
                | WRITE error VALWR PARENTESISR {: System.out.println("Error en console.write"); :}       
                
;

VALWR       ::= identificador:id {: RESULT=id; :} | STRING:str {: RESULT=str.substring(1,str.length()-1);; :} | UNIRSTRNG:ustr {: RESULT=ustr; :} | error {: System.out.println("Se esperaba un String"); :};