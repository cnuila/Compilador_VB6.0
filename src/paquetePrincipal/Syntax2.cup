import java_cup.runtime.Symbol;
import java.util.ArrayList;

class parser2;

parser code
{:
    public int cont = 0;    
    public ArrayList<String> errores;
    public TablaSimbolos tablaSimbolos; 
    public int offset = 0;
    public int cantVarsCreadas = 0;    

    public void setErrores(ArrayList<String> _errores){
        errores = _errores;
    }
    
    public void setTablaSimbolos(TablaSimbolos _tabla){
        tablaSimbolos = _tabla;
    }

:}

terminal IF, ELSE, END, THEN, ELSEIF, IGUAL, STRUCTURE, saltoLinea, DIM, COMA, AS, BOOLEANTYPE, TRUE, FALSE, INTEGERTYPE, STRINGTYPE, AND, OR, NOT, NEW, MODULE, SUB, PARENTESISL, PARENTESISR, EXIT, FOR, TO, NEXT, WHILE, DO, LOOP, RETURN, CONCATSTRING, FUNCTION, READ, WRITE;
terminal String identificador, STRING, INTEGER, OPADICION, OPMULTI, OPREL, LLAMADOSTRUC;

nonterminal S, MDLINSTRUC, MDLINP, SUBPROCE, FUNC, WRCONSOLE, STRUCTINSTRUC, UNIRSTRNG, VALWR, OPARIT, DECLARACION, OPP, OP, CALL, PARAMCALL, VARCALL, VAL, VALASIGN, VALINT, OPASING, ASIGN, ASIGNINT, ASIGNOTRO, VALCOND, CONDICION, CONDICIONP, RETVAL, SIFSTATEMENT, IFSTATEMENT, STATEMENTS,STRUCTUREDECLA, ASIGNSTRUC, COUNTER, TIPOIGUAL, VARPARAMS, PARAMS,M,VALUNIRSTR, OPCONDICION, T, FORSTATEMENT, DOWHILESTATE;
nonterminal String TIPO, CANTVARS, VARS, CANTVARS2, VARS2;

precedence left IGUAL;
precedence left OPREL;
precedence left OPADICION;
precedence left OPMULTI;

start with S;

S      ::= MODULE identificador:id saltoLinea MDLINSTRUC:m END MODULE {:            
            System.out.println("Listo Module");       
        :}
; 

//if m != null
//Instrucciones dentro del Module
MDLINSTRUC  ::= DECLARACION:d MDLINSTRUC:md {:                    
                :}
                | saltoLinea MDLINSTRUC:md {:
                :}
                | FUNC:f MDLINSTRUC:md {:                    
                :}
                | SUBPROCE:s MDLINP:md {:                    
                :}
                | STRUCTUREDECLA:sd MDLINSTRUC:md {:                    
                    
                :}
;

MDLINP      ::= DECLARACION:d MDLINP:m {:                
                :}
                | saltoLinea MDLINP:m {:     
                :}
                | SUBPROCE:s MDLINP:m {:

                :}
                | FUNC:f MDLINP:m {:
                :}
                | STRUCTUREDECLA:sd MDLINP:m {:
                :} 
                | saltoLinea {:
                :}
;

//Intrucciones de una Structure
STRUCTUREDECLA   ::= STRUCTURE identificador:id saltoLinea STRUCTINSTRUC:s END STRUCTURE {:
                :}
;

STRUCTINSTRUC   ::= DECLARACION:d STRUCTINSTRUC:s {:
                    :} 
                    | saltoLinea STRUCTINSTRUC:s {:
                    :} 
                    | saltoLinea {:
                    :}
;

//Instrucciones de un subprocedure
SUBPROCE    ::= SUB identificador:id PARENTESISL PARAMS:p PARENTESISR saltoLinea STATEMENTS:s END SUB {::}
;

//Instrucciones de una función
FUNC        ::= FUNCTION identificador:id PARENTESISL PARAMS:p PARENTESISR AS TIPO:t saltoLinea STATEMENTS:s END FUNCTION {::}
;

//gramática parámetros
PARAMS      ::=  VARPARAMS:v {::} 
                | {::}
;

VARPARAMS      ::= identificador:id AS TIPO:t COMA VARS2:v {:
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }
                    :}
                    | identificador:id COMA CANTVARS2:c COMA VARS2:v {:
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }
                    :}
                    | identificador:id COMA CANTVARS2:c {: 
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }
                    :}
                    | identificador:id AS TIPO:t {:
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }  
                    :}
;

VARS2           ::= CANTVARS2:c COMA VARS2:v {: RESULT = c; :}
                    | CANTVARS2:c {: RESULT = c; :}                
;

CANTVARS2       ::= identificador:id COMA CANTVARS2:c {:
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }
                        RESULT = c;
                    :}
                    | identificador:id AS TIPO:t {:
                        int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                        boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                        if (!esValida){
                            errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                        }
                        RESULT = t;
                    :}
;

//statements
STATEMENTS  ::= DECLARACION:d STATEMENTS:s {::}
                | saltoLinea STATEMENTS:s {::}
                | EXIT SUB STATEMENTS:s {::}
                | EXIT FUNCTION STATEMENTS:s {::}
                | ASIGN:a STATEMENTS:s {::}
                | RETVAL:r STATEMENTS:s {::}
                | CALL:c STATEMENTS:s {::}
                | WRCONSOLE:w STATEMENTS:s {::}
                | IFSTATEMENT:i STATEMENTS:s {::}
                | FORSTATEMENT:f STATEMENTS:s {::}
                |  DOWHILESTATE:d STATEMENTS:s {::}
                |{::}
;    

IFSTATEMENT      ::= IF CONDICION:c THEN M:m saltoLinea STATEMENTS:s SIFSTATEMENT:s2 END IF{::}
;        

SIFSTATEMENT ::= ELSEIF CONDICION:c THEN saltoLinea STATEMENTS:s SIFSTATEMENT:s2  {::}
                |  ELSE saltoLinea STATEMENTS:s {::} 
                | {::}
;


DOWHILESTATE  ::= DO WHILE CONDICION:c saltoLinea STATEMENTS:s LOOP{::}
;

FORSTATEMENT  ::= FOR COUNTER:c TO OPARIT:o saltoLinea STATEMENTS:s NEXT{::}
;

RETVAL      ::= RETURN VAL:v {::}
;

VAL         ::= VALASIGN:v {::} 
                | VALINT:v {::}
;

//Instrucciones del for
COUNTER     ::= ASIGNINT:ai {::} 
                | identificador:id AS INTEGERTYPE IGUAL OPARIT:op{::}
;

//llamado de funcion o sub procedure
CALL        ::= identificador:i PARENTESISL PARAMCALL:p PARENTESISR {::}
;                

PARAMCALL   ::= VARCALL:v {::} 
                | {::}
;

VARCALL     ::= VARCALL:v COMA VAL:val {::}
                | VAL:v {::}
;

//gramática condiciones
CONDICION   ::= CONDICION:c AND CONDICIONP:c1 {::}
                | CONDICION:c OR CONDICIONP:c1 {::}
                | NOT CONDICIONP:c {::}
;
CONDICION   ::= CONDICIONP:c {: :};

CONDICIONP  ::= VALCOND:v OPCONDICION:o VALCOND:v2 {::};

OPCONDICION ::= OPREL:o {: :} 
                | IGUAL {: :}
;              

VALCOND     ::= VALASIGN:v {::}  
                | VALINT:v {::} 
;

//gramática asignacion
ASIGN       ::= ASIGNOTRO:a {::}
                | ASIGNINT:a {::}
                | ASIGNSTRUC:a {::}
; 

ASIGNOTRO   ::= identificador:id IGUAL VALASIGN:v {::}
;

ASIGNSTRUC  ::= LLAMADOSTRUC:l IGUAL VALASIGN:va {::} 
                | LLAMADOSTRUC:l OPASING:o VALINT:v{::}
;

VALASIGN    ::= STRING:str {::} 
                | TRUE {::} 
                | FALSE {::} 
                | UNIRSTRNG:ustr {::} 
                | READ {::} 
;

UNIRSTRNG   ::= VALUNIRSTR:v CONCATSTRING UNIRSTRNG:ustr {::} 
                | VALUNIRSTR:v CONCATSTRING VALUNIRSTR:v2 {::}
;

VALUNIRSTR  ::= STRING:str {::} | identificador:id {::};

ASIGNINT    ::= identificador:id OPASING:o VALINT:v {::}
;

OPASING     ::= IGUAL {::} 
                | OPMULTI:op IGUAL {::}  
                | OPADICION:op IGUAL {::}  
;

VALINT      ::= OPARIT:o {::};

//gramática operaciones aritméticas
OPARIT      ::= OPARIT:o OPADICION:oPa OP:op {::} 
                | OP:o {::} 
;

OP          ::= OP:o OPMULTI:oM OPP:op {::} 
                | OPP:o {::} 
;

OPP         ::= INTEGER:i {::} 
                | identificador:id {: :} 
                | CALL:c {::}  
                | PARENTESISL OPARIT:o PARENTESISR {::} 
;

//gramática declaración de variables
DECLARACION ::= DIM T;

T           ::= identificador:id AS TIPOIGUAL:t {::}
                | identificador:id AS TIPO:t COMA VARS:v {:
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }
                :}
                | identificador:id COMA CANTVARS:c COMA VARS:v {:
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }
                :}
                | identificador:id COMA CANTVARS:c {: 
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }
                :}
                | identificador:id AS TIPO:t {:
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }                   
                :}
;

VARS        ::= CANTVARS:c COMA VARS:v {: RESULT = c; :}
                | CANTVARS:c {: RESULT = c; :}                
;

CANTVARS    ::= identificador:id COMA CANTVARS:c {:
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,c);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }
                    RESULT = c;
                :}
                | identificador:id AS TIPO:t {:                    
                    int posSimbolo = tablaSimbolos.buscarSimbolo(id,t);
                    boolean esValida = tablaSimbolos.comprobarAmbito(posSimbolo);
                    if (!esValida){
                        errores.add("Error: Linea: "+ (idleft + 1) + " Columna: " + (idright + 1) + " ya existe la variable "+ id + " en ese ambito");
                    }
                    RESULT = t;
                :}
;

TIPOIGUAL   ::= INTEGERTYPE IGUAL OPARIT:o  {::}
                | STRINGTYPE IGUAL STRING:str {::}
                | BOOLEANTYPE IGUAL TRUE {: :}
                | BOOLEANTYPE IGUAL FALSE {::}
                | STRINGTYPE IGUAL UNIRSTRNG:ustr {::}
                | identificador:id IGUAL NEW CALL:c {: :}
;

TIPO        ::= INTEGERTYPE {: RESULT="INTEGER"; :} | STRINGTYPE {: RESULT="STRING"; :} | BOOLEANTYPE {: RESULT="BOOLEAN"; :} | identificador:id {: RESULT=id; :} ;

//gramática escribir en consola
WRCONSOLE   ::= WRITE PARENTESISL VALWR:v PARENTESISR {::}
                
;

VALWR       ::= identificador:id {: :} 
                | STRING:str {: :} 
                | UNIRSTRNG:ustr {:  :}
; 

M           ::= {: :};